// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: customer.sql

package datacustomer

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAddressToAccount = `-- name: AddAddressToAccount :exec
INSERT INTO addresses (
                       account_id, address_1, address_2, city, state_id, zip_code, recipient_name
                       ) VALUES (
                                 $1, $2, $3, $4, $5, $6, $7
                                )
`

type AddAddressToAccountParams struct {
	AccountID     int32
	Address1      string
	Address2      pgtype.Text
	City          string
	StateID       int32
	ZipCode       int16
	RecipientName string
}

func (q *Queries) AddAddressToAccount(ctx context.Context, arg AddAddressToAccountParams) error {
	_, err := q.db.Exec(ctx, addAddressToAccount,
		arg.AccountID,
		arg.Address1,
		arg.Address2,
		arg.City,
		arg.StateID,
		arg.ZipCode,
		arg.RecipientName,
	)
	return err
}

const addState = `-- name: AddState :one
INSERT INTO address_states (name) VALUES ($1)
RETURNING id, name
`

func (q *Queries) AddState(ctx context.Context, name string) (AddressState, error) {
	row := q.db.QueryRow(ctx, addState, name)
	var i AddressState
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
    full_name, email, username, password
) VALUES (
             $1, $2, $3, $4
         )
RETURNING id, username, password, full_name, email, created_on, last_login
`

type CreateAccountParams struct {
	FullName string
	Email    string
	Username string
	Password string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.FullName,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.CreatedOn,
		&i.LastLogin,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const deleteAllAccounts = `-- name: DeleteAllAccounts :exec
DELETE FROM accounts
`

func (q *Queries) DeleteAllAccounts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllAccounts)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, username, password, full_name, email, created_on, last_login FROM accounts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.CreatedOn,
		&i.LastLogin,
	)
	return i, err
}

const getAccountAddresses = `-- name: GetAccountAddresses :many
SELECT addresses.id, addresses.account_id, addresses.address_1, addresses.address_2, addresses.city, addresses.state_id, addresses.zip_code, addresses.recipient_name, addresses.added_on, address_states.name AS state_name FROM addresses
    LEFT JOIN address_states ON addresses.state_id = address_states.id
    WHERE account_id = $1
`

type GetAccountAddressesRow struct {
	ID            int32
	AccountID     int32
	Address1      string
	Address2      pgtype.Text
	City          string
	StateID       int32
	ZipCode       int16
	RecipientName string
	AddedOn       pgtype.Timestamp
	StateName     pgtype.Text
}

func (q *Queries) GetAccountAddresses(ctx context.Context, accountID int32) ([]GetAccountAddressesRow, error) {
	rows, err := q.db.Query(ctx, getAccountAddresses, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountAddressesRow
	for rows.Next() {
		var i GetAccountAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Address1,
			&i.Address2,
			&i.City,
			&i.StateID,
			&i.ZipCode,
			&i.RecipientName,
			&i.AddedOn,
			&i.StateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAccounts = `-- name: GetAllAccounts :many
SELECT id, username, password, full_name, email, created_on, last_login FROM accounts
ORDER BY created_on
`

func (q *Queries) GetAllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.FullName,
			&i.Email,
			&i.CreatedOn,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :many
UPDATE accounts SET full_name = $2, email = $3, username = $4, password = $5 WHERE id = $1 RETURNING id, username, password, full_name, email, created_on, last_login
`

type UpdateAccountParams struct {
	ID       int32
	FullName string
	Email    string
	Username string
	Password string
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, updateAccount,
		arg.ID,
		arg.FullName,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.FullName,
			&i.Email,
			&i.CreatedOn,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
